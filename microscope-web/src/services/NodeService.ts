import { ydoc } from '../hooks/useYjs';
import type { TimelineNode, NodeType } from '../types/timeline';
import { v4 as uuidv4 } from 'uuid';
import { extractTags } from '../utils/parser';
import * as Y from 'yjs';

// The Y.js map that stores our nodes, keyed by their ID.
const nodesMap = ydoc.getMap<TimelineNode>('nodes');

/**
 * NodeService provides a static API for CRUD (Create, Read, Update, Delete)
 * operations on TimelineNode objects within the Y.js document.
 */
export class NodeService {
  /**
   * Creates a new node with sensible defaults and adds it to the document.
   * @param props - The properties for the new node. 'type' and 'title' are required.
   * @returns The fully-formed TimelineNode that was created.
   */
  static addNode(
    props: Partial<Omit<TimelineNode, 'id'>> & { type: NodeType; title: string }
  ): TimelineNode {
    const defaults: Omit<TimelineNode, 'id' | 'type' | 'title'> = {
      parentId: null,
      description: '',
      tone: 'light',
      isGhost: false,
      isBookend: false,
      order: Date.now(),
      tags: [], // Use timestamp for simple, incremental ordering.
    };

    const newNode: TimelineNode = {
      ...defaults,
      ...props,
      id: uuidv4(), // The new ID is always generated by the service.
    };

    // Ensure tags are parsed on creation
    newNode.tags = extractTags(newNode.description);

    ydoc.transact(() => {
      nodesMap.set(newNode.id, newNode);
    });

    console.log('NodeService: Added node', newNode);
    return newNode;
  }

  /**
   * Updates one or more fields of an existing node.
   * @param nodeId - The ID of the node to update.
   * @param fields - An object with the fields to update.
   */
  static updateNode(nodeId: string, fields: Partial<TimelineNode>) {
    const existingNode = nodesMap.get(nodeId);

    if (existingNode) {
      // If the description is being updated, we must also update the tags.
      if (typeof fields.description === 'string') {
        fields.tags = extractTags(fields.description);
      }

      // Create the updated node object by merging existing and new fields.
      const updatedNode = { ...existingNode, ...fields };
      ydoc.transact(() => {
        nodesMap.set(nodeId, updatedNode);
      });
      console.log('NodeService: Updated node', updatedNode);
    } else {
      console.warn(`NodeService: updateNode called with non-existent nodeId '${nodeId}'`);
    }
  }

  /**
   * Deletes a node from the document.
   * @param nodeId - The ID of the node to delete.
   */
  static deleteNode(nodeId: string) {
    if (nodesMap.has(nodeId)) {
      ydoc.transact(() => {
        nodesMap.delete(nodeId);
      });
      console.log('NodeService: Deleted node', nodeId);
    } else {
      console.warn(`NodeService: deleteNode called with non-existent nodeId '${nodeId}'`);
    }
  }

  /**
   * Retrieves a node by its ID.
   * @param nodeId The ID of the node to retrieve.
   * @returns The TimelineNode if found, otherwise undefined.
   */
  static getNode(nodeId: string): TimelineNode | undefined {
    return nodesMap.get(nodeId);
  }

  /**
   * Retrieves all nodes as an array.
   * @returns An array of all TimelineNode objects.
   */
  static getAllNodes(): TimelineNode[] {
    return Array.from(nodesMap.values());
  }
}

// --- Background Tag Synchronization ---

/**
 * This observer automatically synchronizes the `tags` field of a node
 * whenever its `description` changes, regardless of which client made the
 * change. This ensures data consistency for all collaborators.
 */
nodesMap.observe((event: Y.YMapEvent<TimelineNode>) => {
  // Use a transaction to batch updates and prevent recursive triggers.
  ydoc.transact(() => {
    event.keysChanged.forEach((key) => {
      const node = nodesMap.get(key);
      if (node) {
        const currentTags = JSON.stringify(node.tags || []);
        const newTags = JSON.stringify(extractTags(node.description));

        if (currentTags !== newTags) {
          console.log(`NodeService (Observer): Syncing tags for node ${node.id}`);
          nodesMap.set(node.id, { ...node, tags: extractTags(node.description) });
        }
      }
    });
  }, 'tag-sync'); // Origin 'tag-sync' helps in debugging and avoiding cycles
});
