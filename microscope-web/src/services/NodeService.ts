import { ydoc } from '../hooks/useYjs';
import type { TimelineNode, NodeType } from '../types/timeline';
import { v4 as uuidv4 } from 'uuid';
import { extractTags } from '../utils/parser';
import * as Y from 'yjs';

// The Y.js map that stores our nodes, keyed by their ID.
const nodesMap = ydoc.getMap<TimelineNode>('nodes');

/**
 * NodeService provides a static API for CRUD (Create, Read, Update, Delete)
 * operations on TimelineNode objects within the Y.js document.
 */
export class NodeService {
  /**
   * Creates a new node with sensible defaults and adds it to the document.
   * @param props - The properties for the new node. 'type' and 'title' are required.
   * @returns The fully-formed TimelineNode that was created.
   */
  static addNode(
    props: Partial<Omit<TimelineNode, 'id'>> & { type: NodeType; title: string }
  ): TimelineNode {
    const defaults: Omit<TimelineNode, 'id' | 'type' | 'title'> = {
      parentId: null,
      description: '',
      tone: 'light',
      isGhost: false,
      isBookend: false,
      order: Date.now(),
      tags: [], // Use timestamp for simple, incremental ordering.
    };

    const newNode: TimelineNode = {
      ...defaults,
      ...props,
      id: uuidv4(), // The new ID is always generated by the service.
    };

    // Ensure tags are parsed on creation
    newNode.tags = extractTags(newNode.description);

    ydoc.transact(() => {
      nodesMap.set(newNode.id, newNode);
    });

    console.log('NodeService: Added node', newNode);
    return newNode;
  }

  /**
   * Updates one or more fields of an existing node.
   * @param nodeId - The ID of the node to update.
   * @param fields - An object with the fields to update.
   */
  static updateNode(nodeId: string, fields: Partial<TimelineNode>) {
    const existingNode = nodesMap.get(nodeId);

    if (existingNode) {
      // If the description is being updated, we must also update the tags.
      if (typeof fields.description === 'string') {
        fields.tags = extractTags(fields.description);
      }

      // Create the updated node object by merging existing and new fields.
      const updatedNode = { ...existingNode, ...fields };
      ydoc.transact(() => {
        nodesMap.set(nodeId, updatedNode);
      });
      console.log('NodeService: Updated node', updatedNode);
    } else {
      console.warn(`NodeService: updateNode called with non-existent nodeId '${nodeId}'`);
    }
  }

  /**
   * Deletes a node from the document.
   * @param nodeId - The ID of the node to delete.
   */
  static deleteNode(nodeId: string) {
    if (nodesMap.has(nodeId)) {
      ydoc.transact(() => {
        nodesMap.delete(nodeId);
      });
      console.log('NodeService: Deleted node', nodeId);
    } else {
      console.warn(`NodeService: deleteNode called with non-existent nodeId '${nodeId}'`);
    }
  }

  /**
   * Retrieves a node by its ID.
   * @param nodeId The ID of the node to retrieve.
   * @returns The TimelineNode if found, otherwise undefined.
   */
  static getNode(nodeId: string): TimelineNode | undefined {
    return nodesMap.get(nodeId);
  }

  /**
   * Retrieves all nodes as an array.
   * @returns An array of all TimelineNode objects.
   */
  static getAllNodes(): TimelineNode[] {
    return Array.from(nodesMap.values());
  }
  /**
   * Inserts a new Period node between two existing Period nodes.
   * The new node will have a fractional order and its tone will be the opposite
   * of the preceding node.
   * @param prevPeriodId - The ID of the Period node before the insertion point.
   * @param nextPeriodId - The ID of the Period node after the insertion point.
   * @returns The newly created TimelineNode, or undefined if insertion fails.
   */
  static insertPeriodBetween(prevPeriodId: string, nextPeriodId: string): TimelineNode | undefined {
    const prevPeriod = nodesMap.get(prevPeriodId);
    const nextPeriod = nodesMap.get(nextPeriodId);

    if (!prevPeriod || !nextPeriod || prevPeriod.type !== 'period' || nextPeriod.type !== 'period') {
      console.error('NodeService: Cannot insert period between non-existent or non-period nodes.');
      return undefined;
    }

    const newOrder = (prevPeriod.order + nextPeriod.order) / 2;
    const newTone = prevPeriod.tone === 'light' ? 'dark' : 'light';

    return NodeService.addNode({
      type: 'period',
      title: 'New Period',
      isGhost: true,
      order: newOrder,
      tone: newTone,
    });
  }

  /**
   * Adds a new Event node as a child of a specified Period node.
   * @param parentId - The ID of the parent Period node.
   * @returns The newly created TimelineNode, or undefined if creation fails.
   */
  static addEventToPeriod(parentId: string): TimelineNode | undefined {
    const parentPeriod = nodesMap.get(parentId);

    if (!parentPeriod || parentPeriod.type !== 'period') {
      console.error(`NodeService: Cannot add event to non-existent or non-period parent '${parentId}'.`);
      return undefined;
    }

    // Find all existing events for this parent, sorted by order
    const existingEvents = Array.from(nodesMap.values())
      .filter(node => node.type === 'event' && node.parentId === parentId)
      .sort((a, b) => a.order - b.order);

    let newOrder: number;
    if (existingEvents.length > 0) {
      // Place after the last existing event for this parent
      const lastEventOrder = existingEvents[existingEvents.length - 1].order;
      // The conceptual "next boundary" for children of this period is parent.order + 1.
      const nextBoundary = parentPeriod.order + 1;
      newOrder = (lastEventOrder + nextBoundary) / 2;
    } else {
      // First event for this period, place it midway between parent.order and parent.order + 1.
      newOrder = parentPeriod.order + 0.5;
    }
    
    // New event inherits tone from parent period
    const newTone = parentPeriod.tone; 

    return NodeService.addNode({
      type: 'event',
      title: 'New Event',
      parentId: parentId,
      tone: newTone,
      order: newOrder,
    });
  }
}

// --- Background Tag Synchronization ---

/**
 * This observer automatically synchronizes the `tags` field of a node
 * whenever its `description` changes, regardless of which client made the
 * change. This ensures data consistency for all collaborators.
 */
nodesMap.observe((event: Y.YMapEvent<TimelineNode>) => {
  // Use a transaction to batch updates and prevent recursive triggers.
  ydoc.transact(() => {
    event.keysChanged.forEach((key) => {
      const node = nodesMap.get(key);
      if (node) {
        const currentTags = JSON.stringify(node.tags || []);
        const newTags = JSON.stringify(extractTags(node.description));

        if (currentTags !== newTags) {
          console.log(`NodeService (Observer): Syncing tags for node ${node.id}`);
          nodesMap.set(node.id, { ...node, tags: extractTags(node.description) });
        }
      }
    });
  }, 'tag-sync'); // Origin 'tag-sync' helps in debugging and avoiding cycles
});
